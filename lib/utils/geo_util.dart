import 'dart:convert';import 'package:get/get.dart';import 'package:http/http.dart' as http;import 'package:geocoding/geocoding.dart';import '../request_model/auth_request_model.dart';import '../response_model/address_response_model.dart';class GeoUtil {  Future<Placemark?> getAddressFromLatLng(      double latitude, double longitude) async {    try {      List<Placemark> placeMarks = await placemarkFromCoordinates(latitude, longitude);      if (placeMarks.isNotEmpty) {        Placemark placeMark = placeMarks[0];        return placeMark;      } else {        return null;      }    } catch (e) {      return null;    }  }  Future<LocationModel?> getApiAddress(double latitude, double longitude) async {    try {      final String url =          'https://maps.googleapis.com/maps/api/geocode/json?latlng=$latitude,$longitude&key=AIzaSyB24Hrv9znLj4PB1Aryc7a3kd3EzwJ9dZk';      print(url);      final response = await http.get(Uri.parse(url));      if (response.statusCode != 200) {        print("Failed to fetch address: ${response.statusCode}");        return null;      }      final body = json.decode(response.body);      final addressData = GoogleAddressResponse.fromJson(body);      String? getAddressComponent(String type) {        for (final result in addressData.results ?? []) {          for (final component in result.addressComponent ?? []) {            if (component.types?.contains(type) ?? false) {              return component.longName;            }          }        }        return null;      }      // Extract required fields      final String premise = getAddressComponent('premise') ?? '';      final String subLocality2 = getAddressComponent('sublocality_level_2') ?? '';      final String subLocality1 = getAddressComponent('sublocality_level_1') ?? '';      final String pinCode = getAddressComponent('postal_code') ?? '';      final String state = getAddressComponent('administrative_area_level_1') ?? '';      // Combine values for the address      final String address1 = [subLocality2, subLocality1].where((e) => e.isNotEmpty).join(', ');      // Build and return the LocationModel      return LocationModel(          address1: address1,          address2: premise,          state: state,          pinCode: pinCode.isNotEmpty ? int.parse(pinCode) : null,          latitude: latitude,          longitude: longitude      );    } catch (e, stackTrace) {      return null;    }  }}