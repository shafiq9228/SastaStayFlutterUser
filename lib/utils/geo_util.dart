import 'dart:convert';import 'package:get/get.dart';import 'package:http/http.dart' as http;import 'package:geocoding/geocoding.dart';import '../request_model/auth_request_model.dart';import '../response_model/address_response_model.dart';import 'dart:math';import '../view_models/auth_view_model.dart';class GeoUtil {  final authViewModel = Get.put(AuthViewModel());  Future<Placemark?> getAddressFromLatLng(      double latitude, double longitude) async {    try {      List<Placemark> placeMarks = await placemarkFromCoordinates(latitude, longitude);      if (placeMarks.isNotEmpty) {        Placemark placeMark = placeMarks[0];        return placeMark;      } else {        return null;      }    } catch (e) {      return null;    }  }  String getDistanceFromLatLonInKm(double lat1, double lon1, double lat2, double lon2) {    if(lat1 == 0.00 || lon1  == 0.00 || lat2 == 0.00 || lon2  == 0.00) return "";    const R = 6371; // Radius of Earth in km    final dLat = _deg2rad(lat2 - lat1);    final dLon = _deg2rad(lon2 - lon1);    final a = sin(dLat / 2) * sin(dLat / 2) +        cos(_deg2rad(lat1)) * cos(_deg2rad(lat2)) *            sin(dLon / 2) * sin(dLon / 2);    final c = 2 * atan2(sqrt(a), sqrt(1 - a));    return "${(R * c).toStringAsFixed(2)} Km from ${authViewModel.locationDetails.value?.address1 ?? ""}"; // Distance in km  }  double _deg2rad(double deg) {    return deg * (pi / 180);  }  Future<LocationModel?> getApiAddress(double latitude, double longitude) async {    try {      final String url =          'https://maps.googleapis.com/maps/api/geocode/json?latlng=$latitude,$longitude&key=AIzaSyB24Hrv9znLj4PB1Aryc7a3kd3EzwJ9dZk';      print(url);      final response = await http.get(Uri.parse(url));      if (response.statusCode != 200) {        print("Failed to fetch address: ${response.statusCode}");        return null;      }      final body = json.decode(response.body);      final addressData = GoogleAddressResponse.fromJson(body);      String? getAddressComponent(String type) {        for (final result in addressData.results ?? []) {          for (final component in result.addressComponent ?? []) {            if (component.types?.contains(type) ?? false) {              return component.longName;            }          }        }        return null;      }      // Extract required fields      final String premise = getAddressComponent('premise') ?? '';      final String subLocality2 = getAddressComponent('sublocality_level_2') ?? '';      final String subLocality1 = getAddressComponent('sublocality_level_1') ?? '';      final String pinCode = getAddressComponent('postal_code') ?? '';      final String state = getAddressComponent('administrative_area_level_1') ?? '';      // Combine values for the address      final String address1 = [subLocality2, subLocality1].where((e) => e.isNotEmpty).join(', ');      // Build and return the LocationModel      return LocationModel(          address1: address1,          address2: premise,          state: state,          pinCode: pinCode.isNotEmpty ? int.parse(pinCode) : null,          latitude: latitude,          longitude: longitude      );    } catch (e, stackTrace) {      return null;    }  }}